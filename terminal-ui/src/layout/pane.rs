//! Pane management for the AI Terminal UI\n//!\n//! This module provides functionality for managing multiple panes within the terminal,\n//! including splitting, resizing, and navigation.\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Style, Color},\n    widgets::{Block, Borders, Paragraph},\n    Frame,\n};\nuse terminal_emulator::CommandBlock;\n\n/// Represents the orientation of a pane split\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SplitOrientation {\n    Horizontal,\n    Vertical,\n}\n\n/// Represents a pane in the terminal UI\n#[derive(Debug)]\npub struct Pane {\n    /// Unique identifier for the pane\n    pub id: usize,\n    /// Area occupied by this pane\n    pub area: Rect,\n    /// Command blocks displayed in this pane\n    pub command_blocks: Vec<CommandBlock>,\n    /// Scroll offset for this pane\n    pub scroll_offset: u16,\n    /// Whether this pane is currently focused\n    pub is_focused: bool,\n}\n\nimpl Pane {\n    /// Create a new pane\n    pub fn new(id: usize, area: Rect) -> Self {\n        Self {\n            id,\n            area,\n            command_blocks: Vec::new(),\n            scroll_offset: 0,\n            is_focused: false,\n        }\n    }\n\n    /// Add a command block to this pane\n    pub fn add_command_block(&mut self, block: CommandBlock) {\n        self.command_blocks.push(block);\n    }\n\n    /// Render the pane\n    pub fn render(&self, f: &mut Frame, style: &PaneStyle) {\n        let block = Block::default()\n            .borders(Borders::ALL)\n            .border_style(if self.is_focused {\n                style.focused_border\n            } else {\n                style.border\n            });\n\n        let inner_area = block.inner(self.area);\n        \n        // Render command blocks in this pane\n        let mut messages_text = Vec::new();\n        for block in &self.command_blocks {\n            messages_text.push(format!(\"$ {}\", block.command));\n            messages_text.push(block.output.clone());\n            messages_text.push(String::new()); // Empty line between blocks\n        }\n\n        let messages_paragraph = Paragraph::new(messages_text.join(\"\\n\"))\n            .block(block)\n            .style(style.background)\n            .scroll((self.scroll_offset, 0));\n\n        f.render_widget(messages_paragraph, self.area);\n    }\n}\n\n/// Styling for panes\n#[derive(Debug, Clone)]\npub struct PaneStyle {\n    pub background: Style,\n    pub border: Style,\n    pub focused_border: Style,\n}\n\nimpl Default for PaneStyle {\n    fn default() -> Self {\n        Self {\n            background: Style::default().bg(Color::Black).fg(Color::White),\n            border: Style::default().fg(Color::DarkGray),\n            focused_border: Style::default().fg(Color::Blue),\n        }\n    }\n}\n\n/// Manages multiple panes in the terminal UI\n#[derive(Debug)]\npub struct PaneManager {\n    /// List of panes\n    panes: Vec<Pane>,\n    /// ID of the currently focused pane\n    focused_pane_id: Option<usize>,\n    /// Next ID to assign to a new pane\n    next_id: usize,\n    /// Style for rendering panes\n    style: PaneStyle,\n}\n\nimpl PaneManager {\n    /// Create a new pane manager\n    pub fn new(area: Rect) -> Self {\n        let mut panes = Vec::new();\n        let initial_pane = Pane::new(0, area);\n        panes.push(initial_pane);\n        \n        Self {\n            panes,\n            focused_pane_id: Some(0),\n            next_id: 1,\n            style: PaneStyle::default(),\n        }\n    }\n\n    /// Get the currently focused pane\n    pub fn focused_pane(&self) -> Option<&Pane> {\n        self.focused_pane_id.and_then(|id| {\n            self.panes.iter().find(|pane| pane.id == id)\n        })\n    }\n\n    /// Get the currently focused pane mutably\n    pub fn focused_pane_mut(&mut self) -> Option<&mut Pane> {\n        self.focused_pane_id.and_then(|id| {\n            self.panes.iter_mut().find(|pane| pane.id == id)\n        })\n    }\n\n    /// Split the focused pane\n    pub fn split_focused_pane(&mut self, orientation: SplitOrientation) -> Result<(), &'static str> {\n        if let Some(focused_id) = self.focused_pane_id {\n            // Find the focused pane\n            let pane_index = self.panes.iter().position(|p| p.id == focused_id)\n                .ok_or(\"Focused pane not found\")?;\n            \n            // Get the area of the pane to split\n            let pane_area = self.panes[pane_index].area;\n            \n            // Create two new areas by splitting the current pane's area\n            let new_areas = match orientation {\n                SplitOrientation::Horizontal => {\n                    let chunks = Layout::default()\n                        .direction(Direction::Horizontal)\n                        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])\n                        .split(pane_area);\n                    [chunks[0], chunks[1]]\n                },\n                SplitOrientation::Vertical => {\n                    let chunks = Layout::default()\n                        .direction(Direction::Vertical)\n                        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])\n                        .split(pane_area);\n                    [chunks[0], chunks[1]]\n                },\n            };\n            \n            // Update the original pane with the first area\n            self.panes[pane_index].area = new_areas[0];\n            \n            // Create a new pane with the second area\n            let new_pane_id = self.next_id;\n            self.next_id += 1;\n            let mut new_pane = Pane::new(new_pane_id, new_areas[1]);\n            \n            // Copy command blocks from the original pane to the new pane\n            new_pane.command_blocks = self.panes[pane_index].command_blocks.clone();\n            \n            // Add the new pane to the list\n            self.panes.push(new_pane);\n            \n            // Focus the new pane\n            self.focused_pane_id = Some(new_pane_id);\n            \n            Ok(())\n        } else {\n            Err(\"No focused pane to split\")\n        }\n    }\n\n    /// Close the focused pane\n    pub fn close_focused_pane(&mut self) -> Result<(), &'static str> {\n        if self.panes.len() <= 1 {\n            return Err(\"Cannot close the last pane\");\n        }\n        \n        if let Some(focused_id) = self.focused_pane_id {\n            // Find the focused pane\n            let pane_index = self.panes.iter().position(|p| p.id == focused_id)\n                .ok_or(\"Focused pane not found\")?;\n            \n            // Remove the pane\n            self.panes.remove(pane_index);\n            \n            // Focus the previous pane (or the first pane if we removed the first one)\n            let new_focused_id = if pane_index > 0 {\n                self.panes[pane_index - 1].id\n            } else {\n                self.panes[0].id\n            };\n            \n            self.focused_pane_id = Some(new_focused_id);\n            \n            Ok(())\n        } else {\n            Err(\"No focused pane to close\")\n        }\n    }\n\n    /// Focus the next pane\n    pub fn focus_next_pane(&mut self) {\n        if self.panes.is_empty() {\n            return;\n        }\n        \n        // Clear focus from all panes\n        for pane in &mut self.panes {\n            pane.is_focused = false;\n        }\n        \n        // Set focus to the next pane\n        let current_index = self.focused_pane_id\n            .and_then(|id| self.panes.iter().position(|p| p.id == id))\n            .unwrap_or(0);\n        \n        let next_index = (current_index + 1) % self.panes.len();\n        self.panes[next_index].is_focused = true;\n        self.focused_pane_id = Some(self.panes[next_index].id);\n    }\n\n    /// Focus the previous pane\n    pub fn focus_prev_pane(&mut self) {\n        if self.panes.is_empty() {\n            return;\n        }\n        \n        // Clear focus from all panes\n        for pane in &mut self.panes {\n            pane.is_focused = false;\n        }\n        \n        // Set focus to the previous pane\n        let current_index = self.focused_pane_id\n            .and_then(|id| self.panes.iter().position(|p| p.id == id))\n            .unwrap_or(0);\n        \n        let prev_index = if current_index > 0 {\n            current_index - 1\n        } else {\n            self.panes.len() - 1\n        };\n        \n        self.panes[prev_index].is_focused = true;\n        self.focused_pane_id = Some(self.panes[prev_index].id);\n    }\n\n    /// Resize panes based on the terminal size\n    pub fn resize(&mut self, area: Rect) {\n        // For now, we'll just update the first pane to fill the entire area\n        // In a more advanced implementation, we would maintain the relative sizes of panes\n        if let Some(pane) = self.panes.get_mut(0) {\n            pane.area = area;\n        }\n    }\n\n    /// Render all panes\n    pub fn render(&self, f: &mut Frame) {\n        for pane in &self.panes {\n            pane.render(f, &self.style);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pane_creation() {\n        let rect = Rect::new(0, 0, 80, 24);\n        let pane = Pane::new(1, rect);\n        \n        assert_eq!(pane.id, 1);\n        assert_eq!(pane.area, rect);\n        assert_eq!(pane.command_blocks.len(), 0);\n        assert_eq!(pane.scroll_offset, 0);\n        assert_eq!(pane.is_focused, false);\n    }\n\n    #[test]\n    fn test_pane_manager_creation() {\n        let rect = Rect::new(0, 0, 80, 24);\n        let pane_manager = PaneManager::new(rect);\n        \n        assert_eq!(pane_manager.panes.len(), 1);\n        assert_eq!(pane_manager.focused_pane_id, Some(0));\n        assert_eq!(pane_manager.next_id, 1);\n    }\n\n    #[test]\n    fn test_split_focused_pane() {\n        let rect = Rect::new(0, 0, 80, 24);\n        let mut pane_manager = PaneManager::new(rect);\n        \n        // Split the focused pane horizontally\n        assert!(pane_manager.split_focused_pane(SplitOrientation::Horizontal).is_ok());\n        assert_eq!(pane_manager.panes.len(), 2);\n        assert_eq!(pane_manager.focused_pane_id, Some(1));\n        \n        // Split the focused pane vertically\n        assert!(pane_manager.split_focused_pane(SplitOrientation::Vertical).is_ok());\n        assert_eq!(pane_manager.panes.len(), 3);\n        assert_eq!(pane_manager.focused_pane_id, Some(2));\n    }\n\n    #[test]\n    fn test_close_focused_pane() {\n        let rect = Rect::new(0, 0, 80, 24);\n        let mut pane_manager = PaneManager::new(rect);\n        \n        // Split to create a second pane\n        assert!(pane_manager.split_focused_pane(SplitOrientation::Horizontal).is_ok());\n        assert_eq!(pane_manager.panes.len(), 2);\n        \n        // Close the focused pane\n        assert!(pane_manager.close_focused_pane().is_ok());\n        assert_eq!(pane_manager.panes.len(), 1);\n        assert_eq!(pane_manager.focused_pane_id, Some(0));\n    }\n\n    #[test]\n    fn test_focus_navigation() {\n        let rect = Rect::new(0, 0, 80, 24);\n        let mut pane_manager = PaneManager::new(rect);\n        \n        // Split to create a second pane\n        assert!(pane_manager.split_focused_pane(SplitOrientation::Horizontal).is_ok());\n        assert_eq!(pane_manager.focused_pane_id, Some(1));\n        \n        // Focus the next pane (should wrap around to the first)\n        pane_manager.focus_next_pane();\n        assert_eq!(pane_manager.focused_pane_id, Some(0));\n        \n        // Focus the previous pane (should wrap around to the second)\n        pane_manager.focus_prev_pane();\n        assert_eq!(pane_manager.focused_pane_id, Some(1));\n    }\n}